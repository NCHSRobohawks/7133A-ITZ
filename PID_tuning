/**

    VEX Autonomous Planner
    Generated Tue, 24 Oct 2017 14:55:37 GMT

    Usage: Tune variables in vap_init() to robot. Call vap_autonomous() to run the autonomous program.

    VEX Autonomous Planner Â© Ruiqi Mao 2014
    All Rights Reserved

**/

float vap_kP[1], vap_kI[1], vap_kD[1], vap_kL[1];
long vap_tolerance[1];
long vap_ticksPerRotation, vap_ticksPerFoot, vap_waitBetweenPID;

void vap_init() {

    vap_kP[0] = 0.0; // Proportional Constant for Robot
    vap_kI[0] = 0.0; // Integral Constant for Robot
    vap_kD[0] = 0.0; // Derivative Constant for Robot
    vap_kL[0] = 0.0; // Integral Limit for Robot
    vap_tolerance[0] = 0; // Tolerance for Robot

    vap_ticksPerRotation = 0; // Number of ticks per full rotation
    vap_ticksPerFoot = 0; // Number of ticks per foot traveled
    vap_waitBetweenPID = 0; // Number of milliseconds to wait after each PID move

}

long vap_target[2] = {0, 0};

task vap_pid() {

    long error[2] = {0, 0};
    long pError[2] = {0, 0};
    long p[2] = {0, 0};
    long i[2] = {0, 0};
    long d[2] = {0, 0};

    while(true) {

        error[0] = vap_target[0] - nMotorEncoder[port6];
        error[1] = vap_target[1] - nMotorEncoder[port3];
        p[0] = error[0];
        p[1] = error[1];
        i[0] = abs(i[0] + error[0]) < vap_kL[0] ? i[0] + error[0] : sgn(i[0] + error[0])*vap_kL[0];
        i[1] = abs(i[1] + error[1]) < vap_kL[0] ? i[1] + error[1] : sgn(i[1] + error[1])*vap_kL[0];
        d[0] = error[0] - pError[0];
        d[1] = error[1] - pError[1];
        motor[port5] = p[0]*vap_kP[0] + i[0]*vap_kI[0] + d[0]*vap_kD[0];
        motor[port6] = p[0]*vap_kP[0] + i[0]*vap_kI[0] + d[0]*vap_kD[0];
        motor[port7] = p[0]*vap_kP[0] + i[0]*vap_kI[0] + d[0]*vap_kD[0];
        motor[port2] = p[1]*vap_kP[0] + i[1]*vap_kI[0] + d[1]*vap_kD[0];
        motor[port3] = p[1]*vap_kP[0] + i[1]*vap_kI[0] + d[1]*vap_kD[0];
        motor[port4] = p[1]*vap_kP[0] + i[1]*vap_kI[0] + d[1]*vap_kD[0];

        wait1Msec(25);

    }

}

void vap_autonomous() {

    vap_init();

    startTask(vap_pid);

    vap_target[0] += 36*vap_ticksPerFoot/12;
    vap_target[1] += 36*vap_ticksPerFoot/12;
    while(abs(nMotorEncoder[port6] - vap_target[0]) > vap_tolerance[0] && abs(nMotorEncoder[port3] - vap_target[1]) > vap_tolerance[0]);
    wait1Msec(vap_waitBetweenPID);

    stopTask(vap_pid);

}
