#pragma config(Sensor, in1,    dr4bL,          sensorPotentiometer)
#pragma config(Sensor, in2,    dr4bR,          sensorPotentiometer)
#pragma config(Sensor, in3,    mogo,           sensorPotentiometer)
#pragma config(Sensor, in4,    manipulator,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  L,              sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  R,              sensorQuadEncoder)
#pragma config(Motor,  port1,           mogoL,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           liftL1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           liftL2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           manipulatorL,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           manipulatorR,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftR1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftR2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           right,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mogoR,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float ticksPerFoot = 344;
float error[5] =  {0,0,0,0,0}
float pError[5] =  {0,0,0,0,0};
float kP[4] = {0.14,0,0,0.1};
float kI[4] = {0,0,0,0};
float kD[4] = {20,0,0,0};
float I[4] = {0,0,0,0};

void pd_base(int target){
	error[0] = target - SensorValue(L);
	error[1] = target - SensorValue(R);
	motor[left] = error[0] * kP[0] + (error[0] - pError[0]) * kD[0];
	motor[right] = error[1]* kP[0] + (error[1] - pError[1]) * kD[0];
	pError[0] = error[0];
	pError[1] = error[1];
}

void pid_mogo(int target){
	error[3] = SensorValue(mogo) - target ;
	I[3] += error[3];
	motor[mogoL] = error[3] *kP[3] + I[3] * kI[3] + (error[3] - pError[3]) * kD[3];
	motor[mogoR] = error[3] *kP[3] + I[3] * kI[3] + (error[3] - pError[3]) * kD[3];
	pError[3] = error[3];
}

void move(int target){
	SensorValue[L] = 0;
	SensorValue[R] = 0;
	pError[0] = 0;
	pError[1] = 0;
	while(abs(SensorValue(L) - target) > 30 && abs(SensorValue(R) - target) > 30){
		pd_base(target);
	}
	motor[left] = 0;
	motor[right] = 0;
}

void mogo_set(int target){

}
task main(){
	motor[liftL1] = 50;
	motor[liftL2] = 50;
	motor[liftR1] = 50;
	motor[liftR2] = 50;
	wait1Msec(2000);
	while(True){
		motor[liftL1] = 20;
		motor[liftL2] = 20;
		motor[liftR1] = 20;
		motor[liftR2] = 20;
		pid_mogo(2000);
}
}
