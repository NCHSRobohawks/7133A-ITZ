
#pragma config(Sensor, in1,    mobile1,        sensorPotentiometer)
#pragma config(Sensor, in2,    mobile2,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  left,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  right,          sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl7,  elevator,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, bar,            sensorQuadEncoder)
#pragma config(Motor,  port1,           bar1,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rf,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rb,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lf,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lb,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           goal2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           goal1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lift1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          bar2,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float kP[4], kI[4], kD[4], kL[4];
long tolerance[4];
long ticksPerRotation, ticksPerFoot, waitBetweenPID;
bool turning = false;
bool mogo_override = false;
long target[6] = {0, 0, SensorValue(mobile1), SensorValue(mobile2), 0, 0};
/*
Constants
* * *
0 - wheel base
1 - Mobile goal intake
2 - Elevator
3 - Chain bar
* * *
*/

void init() {
		SensorValue[bar] = 0;
		SensorValue[left] = 0;
		SensorValue[right] = 0;
		/*
    SensorType[in3] = sensorNone;
    wait1Msec(1000);
    SensorType[in3] = sensorGyro;
    wait1Msec(2000);
    SensorFullCount[in3] = 3600;
		SensorValue[in3] = 0;
		*/

    //Wheel base constants
    kP[0] = -0.12;
    kI[0] = -1.4;
    kD[0] = 0;
    kL[0] = 0.0;
    tolerance[0] = 30;

    //Mobile goal lift constants
    kP[1] = 0.35;
    kI[1] = 0.7;
    kD[1] = -0.00;
    kL[1] = 20;
    tolerance[1] = 30;

    //Gyro constants
    kP[2] = -0.43;
    kI[2] = -1.4;
    kD[2] = 0.1;
    kL[2] = 0.0;
    tolerance[2] = 40;

    //Chain bar constants
    kP[3] = 10;
    kI[3] = 4;
    kD[3] = 2;
    kL[3] = 0.0;
    tolerance[3] = 0;

    ticksPerRotation = 0; // Number of ticks per full rotation
    ticksPerFoot = 343.95; // Number of ticks per foot traveled


    waitBetweenPID = 1000; // Number of milliseconds to wait after each PID move


}



/*
Targets
* * *
0 - left wheels
1 - right wheels
2 - left mobile goal
3 - right mobile goal
4 - degrees
5 - chain bar
* * *
*/
task pid() {

    long error[6] = {0, 0, 0, 0, 0, 0};
    long pError[6] = {0, 0, 0, 0, 0, 0};
    long p[6] = {0, 0, 0, 0, 0, 0};
    long i[6] = {0, 0, 0, 0, 0, 0};
    long d[6] = {0, 0, 0, 0, 0, 0};

    while(true) {
    	if(true){
       	error[4] = target[4] - SensorValue(in3);
        p[4] = error[4];
        i[4] = abs(i[4] + error[4]) < kL[2] ? i[4] + error[0] : sgn(i[4] + error[4])*kL[2];
        d[4] = error[4] - pError[4];
        motor[port4] = -(p[4]*kP[2] + i[4]*kI[2]+ d[4]*kD[2]);
        motor[port5] = -(p[4]*kP[2] + i[4]*kI[2] + d[4]*kD[2]);
        motor[port2] = p[4]*kP[2] + i[4]*kI[2] + d[4]*-kD[2];
        motor[port3] = p[4]*kP[2] + i[4]*kI[2] + d[4]*kD[2];
      }
      if(!turning){
      		error[0] = target[0] - SensorValue(left);
	        error[1] = target[1] - SensorValue(right);
	        p[0] = error[0];
	        p[1] = error[1];
	        i[0] = abs(i[0] + error[0]) < kL[0] ? i[0] + error[0] : sgn(i[0] + error[0])*kL[0];
	        i[1] = abs(i[1] + error[1]) < kL[0] ? i[1] + error[1] : sgn(i[1] + error[1])*kL[0];
	        d[1] = error[1] - pError[1];
	        d[2] = error[2] - pError[2];
	        motor[port4] += p[0]*kP[0] + i[0]*kI[0] + d[0]*kD[0];
	        motor[port5] += p[0]*kP[0] + i[0]*kI[0] + d[0]*kD[0];
	        motor[port2] += p[1]*kP[0] + i[1]*kI[0] + d[1]*kD[0];
	        motor[port3] += p[1]*kP[0] + i[1]*kI[0] + d[1]*kD[0];
	      }

        error[2] = target[2] - SensorValue(mobile1);
        error[3] = target[3] - SensorValue(mobile2);
        error[5] = target[5] - SensorValue(bar);

        p[2] = error[2];
        p[3] = error[3];
        p[5] = error[5];

        i[2] = abs(i[2] + error[2]) < kL[0] ? i[2] + error[2] : sgn(i[2] + error[2])*kL[0];
        i[3] = abs(i[3] + error[3]) < kL[0] ? i[3] + error[3] : sgn(i[3] + error[3])*kL[0];
        i[5] = abs(i[5] + error[5]) < kL[0] ? i[5] + error[5] : sgn(i[5] + error[5])*kL[0];
        d[0] = error[0] - pError[0];
        //displayLCDNumber(0,1, d[0]);
				d[2] = error[3] - pError[3];
        d[3] = error[3] - pError[3];
        d[5] = error[5] - pError[5];
        if(!mogo_override){
        motor[port7] = p[2]*kP[1] + i[2]*kI[1] + d[2]*kD[1];
        motor[port6] = p[3]*kP[1] + i[3]*kI[1] + d[3]*kD[1];
      }
        motor[port1] = p[5]*kP[3] + i[5]*kI[3] + d[5]*kD[3];
        motor[port10] = p[5]*kP[3] + i[5]*kI[3] + d[5]*kD[3];
        pError[0] = error[0];
        pError[1] = error[1];
        pError[2] = error[2];
        pError[3] = error[3];
        pError[4] = error[4];
        pError[5] = error[5];
        wait1Msec(25);
    }

}

int reverse = 1;
int half = 1;
int rl=0;
int hl=0;
int sl=0;
int ll=0;
bool lower = false;
long error[2] = {0, 0};
long i[2] = {0,0};

void mogo_forward(int inches){
	target[0] = target[1] = inches*ticksPerFoot/12;
	while(abs(SensorValue(left) - target[0]) > tolerance[0] && abs(SensorValue(right) - target[1]) > tolerance[0]);

}

void forward(int inches){
	target[0] = target[1] = -inches*ticksPerFoot/12;
	while(abs(SensorValue(left) - target[0]) > tolerance[0] && abs(SensorValue(right) - target[1]) > tolerance[0]);
}

void turn(int degrees10){
	turning = true;
	target[4] += degrees10;
	while(true);
	while(abs(SensorValue(in3) - target[4]) > tolerance[2]);
	turning = false;
}
void arm_raise(){
	target[5] = 60;
}
void mogo_lower() {
	mogo_override = true;
	motor[port6] = -127;
	motor[port7] = -127;
	wait1Msec(500);
	mogo_override = false;
	target[2] = 790;
	target[3] = 310;
	while(abs(SensorValue(mobile1) - target[2]) > tolerance[1] && abs(SensorValue(mobile2) - target[3]) > tolerance[1]);

}
void mogo_raise() {

	target[2] = 3800;
	target[3] = 3130;
	while(abs(SensorValue(mobile1) - target[2]) > tolerance[1] && abs(SensorValue(mobile2) - target[3]) > tolerance[1]);
}




task main() {
	//SensorValue[claw] = 1;
	wait1Msec(1000);
	startTask(pid);
	arm_raise();
	/*
	wait1Msec(500);
	mogo_lower();
	wait1Msec(waitBetweenPID);
	mogo_forward(65);
	mogo_raise();
	*/
}
