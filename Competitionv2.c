#pragma config(Sensor, in1,    mobile1,        sensorPotentiometer)
#pragma config(Sensor, in2,    mobile2,        sensorPotentiometer)
#pragma config(Sensor, in4,    bar,            sensorNone)
#pragma config(Sensor, dgtl1,  left,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  right,          sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl7,  elevator,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, bar,            sensorQuadEncoder)
#pragma config(Motor,  port1,           bar1,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rf,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rb,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lf,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lb,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           goal2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           goal1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lift1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          bar2,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"


float kP[4], kI[4], kD[4], kL[4];
long tolerance[4];
long ticksPerRotation, ticksPerFoot, waitBetweenPID;
bool turning = false;
bool mogo_override = false;
long target[6] = {0,0,0,0,0,0};
/*
Constants
* * *
0 - wheel base
1 - Mobile goal intake
2 - Elevator
3 - Chain bar
* * *
*/

void init() {
		SensorValue[bar] = 0;
		SensorValue[left] = 0;
		SensorValue[right] = 0;
    SensorType[in3] = sensorNone;
    wait1Msec(1000);
    SensorType[in3] = sensorGyro;
    wait1Msec(2000);
    SensorFullCount[in3] = 3600;
		SensorValue[in3] = 0;
		long targets[6] = {SensorValue(left), SensorValue(right), SensorValue(mobile1), SensorValue(mobile2), SensorValue(in3), SensorValue(bar)};
		target = targets;
    //Wheel base constants
    kP[0] = -0.12;
    kI[0] = -1.4;
    kD[0] = 0;
    kL[0] = 0.0;
    tolerance[0] = 30;

    //Mobile goal lift constants
    kP[1] = 0.35;
    kI[1] = 0.7;
    kD[1] = -0.00;
    kL[1] = 20;
    tolerance[1] = 30;

    //Gyro constants
    kP[2] = -0.43;
    kI[2] = -1.4;
    kD[2] = 0.1;
    kL[2] = 0.0;
    tolerance[2] = 40;

    //Chain bar constants
    kP[3] = 10;
    kI[3] = 4;
    kD[3] = 2;
    kL[3] = 0.0;
    tolerance[3] = 0;

    ticksPerRotation = 0; // Number of ticks per full rotation
    ticksPerFoot = 343.95; // Number of ticks per foot traveled


    waitBetweenPID = 1000; // Number of milliseconds to wait after each PID move


}



/*
Targets
* * *
0 - left wheels
1 - right wheels
2 - left mobile goal
3 - right mobile goal
4 - degrees
5 - chain bar
* * *
*/
task pid() {

    long error[6] = {0, 0, 0, 0, 0, 0};
    long pError[6] = {0, 0, 0, 0, 0, 0};
    long p[6] = {0, 0, 0, 0, 0, 0};
    long i[6] = {0, 0, 0, 0, 0, 0};
    long d[6] = {0, 0, 0, 0, 0, 0};

    while(true) {
    	if(true){
       	error[4] = target[4] - SensorValue(in3);
        p[4] = error[4];
        i[4] = abs(i[4] + error[4]) < kL[2] ? i[4] + error[0] : sgn(i[4] + error[4])*kL[2];
        d[4] = error[4] - pError[4];
        motor[port4] = -(p[4]*kP[2] + i[4]*kI[2]+ d[4]*kD[2]);
        motor[port5] = -(p[4]*kP[2] + i[4]*kI[2] + d[4]*kD[2]);
        motor[port2] = p[4]*kP[2] + i[4]*kI[2] + d[4]*-kD[2];
        motor[port3] = p[4]*kP[2] + i[4]*kI[2] + d[4]*kD[2];
      }
      if(!turning){
      		error[0] = target[0] - SensorValue(left);
	        error[1] = target[1] - SensorValue(right);
	        p[0] = error[0];
	        p[1] = error[1];
	        i[0] = abs(i[0] + error[0]) < kL[0] ? i[0] + error[0] : sgn(i[0] + error[0])*kL[0];
	        i[1] = abs(i[1] + error[1]) < kL[0] ? i[1] + error[1] : sgn(i[1] + error[1])*kL[0];
	        d[1] = error[1] - pError[1];
	        d[2] = error[2] - pError[2];
	        motor[port4] += p[0]*kP[0] + i[0]*kI[0] + d[0]*kD[0];
	        motor[port5] += p[0]*kP[0] + i[0]*kI[0] + d[0]*kD[0];
	        motor[port2] += p[1]*kP[0] + i[1]*kI[0] + d[1]*kD[0];
	        motor[port3] += p[1]*kP[0] + i[1]*kI[0] + d[1]*kD[0];
	      }

        error[2] = target[2] - SensorValue(mobile1);
        error[3] = target[3] - SensorValue(mobile2);
        error[5] = target[5] - SensorValue(bar);

        p[2] = error[2];
        p[3] = error[3];
        p[5] = error[5];

        i[2] = abs(i[2] + error[2]) < kL[0] ? i[2] + error[2] : sgn(i[2] + error[2])*kL[0];
        i[3] = abs(i[3] + error[3]) < kL[0] ? i[3] + error[3] : sgn(i[3] + error[3])*kL[0];
        i[5] = abs(i[5] + error[5]) < kL[0] ? i[5] + error[5] : sgn(i[5] + error[5])*kL[0];
        d[0] = error[0] - pError[0];
        //displayLCDNumber(0,1, d[0]);
				d[2] = error[3] - pError[3];
        d[3] = error[3] - pError[3];
        d[5] = error[5] - pError[5];
        if(!mogo_override){
        motor[port7] = p[2]*kP[1] + i[2]*kI[1] + d[2]*kD[1];
        motor[port6] = p[3]*kP[1] + i[3]*kI[1] + d[3]*kD[1];
      }
        motor[port1] = p[5]*kP[3] + i[5]*kI[3] + d[5]*kD[3];
        motor[port10] = p[5]*kP[3] + i[5]*kI[3] + d[5]*kD[3];
        pError[0] = error[0];
        pError[1] = error[1];
        pError[2] = error[2];
        pError[3] = error[3];
        pError[4] = error[4];
        pError[5] = error[5];
        wait1Msec(25);

    }

}

int reverse = 1;
int half = 1;
int rl=0;
int hl=0;
int sl=0;
int ll=0;
bool lower = false;
long error[2] = {0, 0};
long i[2] = {0,0};

void mogo_forward(int inches){
	target[0] = target[1] = inches*ticksPerFoot/12;
	while(abs(SensorValue(left) - target[0]) > tolerance[0] && abs(SensorValue(right) - target[1]) > tolerance[0]);

}

void forward(int inches){
	target[0] = target[1] = -inches*ticksPerFoot/12;
	while(abs(SensorValue(left) - target[0]) > tolerance[0] && abs(SensorValue(right) - target[1]) > tolerance[0]);
}

void turn(int degrees10){
	turning = true;
	target[4] += degrees10;
	while(true);
	while(abs(SensorValue(in3) - target[4]) > tolerance[2]);
	turning = false;
}
void arm_raise(){
	target[5] = 60;
}
void mogo_lower() {
	mogo_override = true;
	motor[port6] = -127;
	motor[port7] = -127;
	wait1Msec(500);
	mogo_override = false;
	target[2] = 790;
	target[3] = 310;
	while(abs(SensorValue(mobile1) - target[2]) > tolerance[1] && abs(SensorValue(mobile2) - target[3]) > tolerance[1]);

}
void mogo_raise() {

	target[2] = 3800;
	target[3] = 3130;
	while(abs(SensorValue(mobile1) - target[2]) > tolerance[1] && abs(SensorValue(mobile2) - target[3]) > tolerance[1]);
}



void red_left_far(){
	startTask(pid);
	mogo_override = true;
  arm_raise();
	wait1Msec(2000);
	mogo_override = false;
	mogo_lower();
	wait1Msec(1000);
	mogo_raise();
}

void red_left_near(){
	arm_raise();
}

void red_right_far(){

}

void red_right_near(){

}

void blue_left_far(){

}

void blue_left_near(){

}

void blue_right_far(){

}

void blue_right_near(){

}

void programming_skills(){

}

string names[] = {"red-left-far", "red-left-near", "red-right-far",
 "red-right-near", "blue-left-far", "blue-left-near", "blue-right-far",
"blue-right-near", "programming-skills"};
int auton = 0;


task lcd_select(){
int pButton = nLCDButtons;
bool calibrated = false;
string str;
bLCDBacklight = True;
displayLCDCenteredString(0, names[auton]);
  while(True){
  	//aut = *autons[auton];
		calibrated ? str = "Cal Gyro: " : str = "Gyro: ";
		displayLCDCenteredString(0, names[auton]);
    displayLCDCenteredString(1, str);
    if(nLCDButtons == 1 && nLCDButtons != pButton && auton != 0){
      auton -=1;
      //clearLCDLine(0);
      //displayLCDCenteredString(0, names[auton]);
    }
    else if(nLCDButtons == 4 && nLCDButtons != pButton && auton != 8){
      auton += 1;
      //clearLCDLine(0);
      //displayLCDCenteredString(0, names[auton]);
    }
    else if(nLCDButtons == 2 && nLCDButtons != pButton){
      //Calibrates gyro sensor and configures scales
    	clearLCDLine(1);
    	displayLCDCenteredString(1, "Calibrating Gyro");
      SensorType[in3] = sensorNone;
      wait1Msec(1000);
      SensorType[in3] = sensorGyro;
      wait1Msec(2000);
      SensorScale[in3] = 260;
      SensorFullCount[in3] = 3600;
      init();
     	calibrated = true;
      clearLCDLine(1);
      SensorValue[claw] = !SensorValue[claw];
      //900 counts = 90 degrees
    }

    pbutton = nLCDButtons;
  }
}



task mobile_goal() {
		while(True){
		if(!lower){
			motor[goal1] = (127 * vexRT[Btn6U]) + (-127 * vexRT[Btn6D]);
			motor[goal2] = (127 * vexRT[Btn6U]) + (-127 * vexRT[Btn6D]);
  }
    else{
        error[0] = 730 - SensorValue(mobile1);
        error[1] = 345 - SensorValue(mobile2);
        i[0] = abs(i[0] + error[0]) < 0 ? i[0] + error[0] : sgn(i[0] + error[0])*0;
        i[1] = abs(i[1] + error[1]) < 0 ? i[0] + error[1] : sgn(i[0] + error[1])*0;
        motor[port7] = error[0]*0.3 + i[0]*0.04;
        motor[port6] = error[1]*0.3 + i[1]*0.04;
        wait1Msec(25);
    }
}
}

void pre_auton()
{
  bStopTasksBetweenModes = False;
  clearLCDLine(0);
  clearLCDLine(1);
  startTask(lcd_select);
}

task autonomous()
{
    /*
void *autons[] = {red_left_far, red_left_near, red_right_far, red_right_near,
   blue_left_far, blue_left_near, blue_right_far, blue_right_near, programming_skills};
  */
  stopTask(lcd_select);

  clearLCDLine(0);
  clearLCDLine(1);
  displayLCDCenteredString(0, "Running Auton");
  displayLCDCenteredString(1, names[auton]);


  switch(auton){
  	case 0:
  		red_left_far();
  	case 1:
  		red_left_near();
  	case 2:
  		red_right_far();
  	case 3:
  		red_right_near();
  	case 4:
  		blue_left_far();
  	case 5:
  		blue_left_near();
  	case 6:
  		blue_right_far();
  	case 7:
  		blue_right_near();
  	case 8:
  		programming_skills();
		}
}
task usercontrol()
{
stopTask(pid);
startTask(mobile_goal);
while(true){

		motor[lf] = reverse * (vexRT[Ch3] + reverse*(vexRT[Ch1]+ vexRT[Ch4]))/half;
		motor[lb] = reverse * (vexRT[Ch3] + reverse*(vexRT[Ch1]+ vexRT[Ch4]))/half;
		motor[rf] = reverse * (vexRT[Ch3] - reverse*(vexRT[Ch1]+ vexRT[Ch4]))/half;
		motor[rb] = reverse * (vexRT[Ch3] - reverse*(vexRT[Ch1]+ vexRT[Ch4]))/half;

		motor[lift1] = (127 * vexRT[Btn5U]) + (-127 * vexRT[Btn5D]);
		motor[lift2] = (127 * vexRT[Btn5U]) + (-127 * vexRT[Btn5D]);

		motor[bar1] = vexRT[Ch2];
		motor[bar2] = vexRT[Ch2];

		if(vexRT[Btn8D]!=rl && rl){
			reverse *= -1;
		}
		rl = vexRT[Btn8D];
		if(vexRT[Btn7D]!=hl && hl){
			half == 1 ? half = 2 : half = 1;
		}
		hl = vexRT[Btn7D];
		if (vexRT[Btn8R]!=sl && sl) {
				SensorValue[claw] = !SensorValue[claw];
		}
		sl = vexRT[Btn8R];

		if(vexRT[Btn8L]!=ll && ll){
					lower = !lower;
				}
		ll = vexRT[Btn8L];
	}
}
